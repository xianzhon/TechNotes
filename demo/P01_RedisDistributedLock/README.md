# 利用 Redis的 setnx 指令实现分布式锁



## 基于 setnx 指令

`setnx`指令：含义是set if Not eXist，如果key不存在，那么就设置key，value，返回1，如果已经存在，那么返回0，不做任何操作。

加锁：`setnx lockKey lockValue`   （返回1表示加锁成功，返回0加锁失败）

释放锁：`del lockKey` 

设置过期时间，使得锁支持超时释放：`expire lockKey 60` 设置 60s 超时释放锁



### 操作步骤

1. 安装 redis-server，可以裸机，或者使用docker的方式，目前使用裸机安装： `sudo apt install redis-server`, 安装后会自动启动 redis server，默认端口 6379
2. 运行 Java 的代码模拟分布式情况下获取锁。观察运行结果，只有一个线程（节点）获取锁成功。同时可以是使用redis-cli 工具，在加锁前后观察redis的数据变化。



### 讨论

利用 redis 的 `setnx` 指令可以用来实现分布式锁，它可以实现非阻塞的方式获取锁，以及超时自动释放锁。其优缺点以及适用场景如下（取自ChatGPT，有待后期验证和修正）

**优点**：

1. 可以有效避免并发访问冲突，防止多个客户端同时修改同一个资源，保证了数据的一致性和可靠性。
2. 实现简单，使用方便，适用于各种语言和框架，具有较好的通用性。
3. 性能较高，因为 Redis 是基于内存的数据库，读写速度很快，同时支持事务操作，可以保证操作的原子性。



**缺点**：

1. 可能存在死锁问题，如果加锁的客户端崩溃或者异常退出，锁将永远不会被释放，导致其他客户端无法获取锁，进而导致系统崩溃。 （纠正：这个应该可以通过设置lockKey 的 expire 过期时间，实现超时删除lockKey，从而自动释放锁）
2. 由于 Redis 是单线程模型，多个客户端同时进行加锁操作可能会导致性能瓶颈和延迟问题。
3. 对于需要长时间占用锁的场景，会导致 Redis 的资源消耗较大，需要考虑 Redis 的性能和可靠性问题。



**使用场景**：

1. 秒杀系统：多个用户同时抢购同一件商品，需要保证每件商品只能被一个用户购买，避免超卖和库存混乱。
2. 分布式任务调度：多个任务执行器同时执行同一个任务，需要保证任务只能被一个任务执行器执行，避免重复执行和数据错乱。
3. 分布式缓存更新：多个客户端同时更新缓存中的同一个数据，需要保证数据的一致性和可靠性，避免数据出现脏读、幻读等问题。
4. 分布式日志写入：多个客户端同时写入同一个日志文件，需要保证日志写入的原子性和互斥性，避免日志数据丢失或错乱。
5. 分布式事务控制：多个服务同时参与同一个分布式事务，需要保证事务的原子性和一致性，避免分布式事务的分支出现数据不一致的情况。

总之，任何需要在分布式环境中保证操作的原子性、互斥性、一致性和可靠性的场景都可以考虑使用 Redis 的 `setnx` 指令实现分布式锁。



## 基于 Redission

Redission 是 Redis 的一个 Java 客户端，它提供了一个可靠的分布式锁实现，支持各种不同的锁类型和功能。



优点：

1. 稳定性高：Redisson 支持多种锁类型，可以根据实际需求选择合适的锁类型，同时它内部对 Redis 锁进行了封装和优化，具有更高的稳定性和可靠性。
2. 功能丰富：Redisson 不仅支持分布式锁，还支持分布式限流、分布式队列、分布式 Map、分布式 Topic 等多种分布式应用场景，可以满足不同的需求。
3. 易用性高：Redisson 集成了 Spring、Spring Boot 等框架，提供了方便的编程接口和依赖注入支持，开发人员可以很方便地使用和管理分布式锁。
4. 性能优异：Redisson 内部使用了 Netty 和线程池等技术，可以高效地与 Redis 进行通信和操作，同时它支持异步和批量操作，可以提升系统的吞吐量和性能。

缺点：

1. 对 Redis 服务器的资源消耗较大：Redisson 使用 Redis 服务器作为分布式锁的存储和管理，会占用一定的 Redis 服务器资源，需要注意 Redis 的性能和可靠性问题。
2. 可能存在死锁问题：如果加锁的客户端崩溃或者异常退出，锁将永远不会被释放，导致其他客户端无法获取锁，进而导致系统崩溃。



### 对比 setnx 和 Redission 两种分布式锁的实现方式 ★

`setnx` 和 Redisson 都可以实现分布式锁，但它们有一些区别：

1. 使用方式不同：`setnx` 是 Redis 的原生指令，需要手动编写 Redis 的连接和指令执行代码；而 Redisson 是 Redis 的 Java 客户端，提供了更方便的编程接口和封装，可以更快速和简单地使用分布式锁。
2. 功能不同：`setnx` 只支持基本的分布式锁功能，不支持可重入锁、公平锁等高级功能；而 Redisson 支持多种锁类型和功能，可以根据实际需求选择合适的锁类型。
3. 可靠性不同：`setnx` 实现分布式锁需要手动编写代码，容易出现逻辑错误和漏洞，对程序稳定性和可靠性有较大的影响；而 Redisson 对 Redis 分布式锁进行了封装和优化，具有更高的稳定性和可靠性。

根据上述区别，可以考虑如下情况使用 `setnx` 和 Redisson：

1. `setnx`：对于只需要实现基本分布式锁功能的应用场景，例如简单的秒杀、抢购系统等，可以考虑使用 `setnx` 实现分布式锁。
2. Redisson：对于需要实现复杂锁功能或者需要更高的稳定性和可靠性的应用场景，例如分布式事务、分布式队列、分布式限流等，可以考虑使用 Redisson 实现分布式锁。同时，如果你使用了 Spring Boot 或者其他 Spring 相关框架，使用 Redisson 可以更方便地集成到项目中。



## 基于 RedLock 实现

Redlock 是一个由 Redis 官方提出的分布式锁算法，可以在多个 Redis 节点之间协同工作，保证分布式锁的可靠性和稳定性。使用 Redlock 实现分布式锁，需要在多个 Redis 节点之间协作，具体实现步骤如下：

1. 向多个 Redis 实例尝试获取锁，每个实例使用相同的锁名称和随机字符串作为锁的值，同时设置相同的过期时间，通常设置为锁的超时时间的几倍。
2. 在大多数 Redis 实例上都成功获取锁时，锁被视为获取成功。否则，释放已经获取的锁并重试获取锁。
3. 锁的持有者必须定期续约锁，以确保锁不会过期。在释放锁之前，必须检查当前持有的锁是否为最新版本的锁。

后面有空再掌握。
